(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{90:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return p}));var a=n(2),r=n(6),i=(n(0),n(96)),o={id:"eql",title:"EQL"},s={unversionedId:"eql",id:"eql",isDocsHomePage:!1,title:"EQL",description:"Using the EQL interface, you can request Pathom to fetch a specific shape of data.",source:"@site/docs/eql.mdx",slug:"/eql",permalink:"/docs/eql",editUrl:"https://github.com/wilkerlucio/pathom3-docs/edit/master/docs/eql.mdx",version:"current",sidebar:"docs",previous:{title:"Smart Maps",permalink:"/docs/smart-maps"},next:{title:"Environment",permalink:"/docs/environment"}},c=[{value:"Using EQL interface",id:"using-eql-interface",children:[{value:"Nested entities",id:"nested-entities",children:[]},{value:"Providing map data",id:"providing-map-data",children:[]},{value:"Providing data via EQL idents",id:"providing-data-via-eql-idents",children:[]},{value:"Providing data with placeholders",id:"providing-data-with-placeholders",children:[]},{value:"Union queries",id:"union-queries",children:[]},{value:"Recursive queries",id:"recursive-queries",children:[]},{value:"Wildcard",id:"wildcard",children:[]}]}],l={rightToc:c};function p(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Using the EQL interface, you can request Pathom to fetch a specific shape of data."),Object(i.b)("p",null,"If you are not familiar with EQL, check ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://edn-query-language.org"}),"https://edn-query-language.org")," for an overview of the syntax."),Object(i.b)("p",null,"The goal of using EQL is to express some data shape (hierarchy) without the values and\nlet Pathom fill in the values."),Object(i.b)("p",null,"Using EQL is also the most efficient way to request multiple things at once with Pathom.\nWith EQL, Pathom knows the full request ahead of time. Therefore, Pathom can use this information\nto optimize the planning and execution."),Object(i.b)("h2",{id:"using-eql-interface"},"Using EQL interface"),Object(i.b)("p",null,"Keep in mind that EQL is about expressing some data hierarchy, to start simple we will\nuse a flat structure to demonstrate the basic usage of the EQL interface:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-clojure"}),"(ns com.wsscode.pathom.docs.eql-demos\n  (:require [com.wsscode.pathom3.connect.built-in.resolvers :as pbir]\n            [com.wsscode.pathom3.connect.indexes :as pci]\n            [com.wsscode.pathom3.interface.eql :as p.eql]))\n\n(def indexes\n  (pci/register\n    [(pbir/constantly-resolver ::pi 3.1415)\n     (pbir/single-attr-resolver ::pi ::tau #(* % 2))]))\n\n(p.eql/process indexes [::pi ::tau])\n; => {::pi 3.1415 ::tau 6.283}\n")),Object(i.b)("h3",{id:"nested-entities"},"Nested entities"),Object(i.b)("p",null,"Using ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://edn-query-language.org/eql/1.0.0/specification.html#_joins"}),"EQL joins")," you\ncan make specific requirements about nested data. In this example we will simulate the\nexistence of many worlds where PI have different values:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-clojure"}),"(def indexes\n  (pci/register\n    [(pbir/constantly-resolver ::pi 3.1415)\n     (pbir/single-attr-resolver ::pi ::tau #(* % 2))\n     ; define a resolver to provide a collection of items\n     (pbir/constantly-resolver ::pi-worlds\n       [{::pi 3.14}\n        {::pi 3.14159}\n        {::pi 6.8}\n        {::tau 20}\n        {::pi 10 ::tau 50}])]))\n\n(p.eql/process indexes\n  ; using a map we are able to specify nested requirements from some attribute\n  [{::pi-worlds [::tau ::pi]}])\n; => {::pi-worlds\n;      [{::tau 6.28\n;        ::pi  3.14}\n;       {::tau 6.28318\n;        ::pi  3.14159}\n;       {::tau 13.6\n;        ::pi  6.8}\n;       {::tau 20\n;        ::pi  3.1415}\n;       {::tau 50\n;        ::pi  10}]}\n")),Object(i.b)("h3",{id:"providing-map-data"},"Providing map data"),Object(i.b)("p",null,"You can provide initial data to the EQL process using the following syntax:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-clojure"}),"(p.eql/process indexes {::pi 2.3} [::tau])\n; => {::tau 4.6}\n")),Object(i.b)("h3",{id:"providing-data-via-eql-idents"},"Providing data via EQL idents"),Object(i.b)("p",null,"Pathom uses the EQL ",Object(i.b)("inlineCode",{parentName:"p"},"ident")," as a form to specify a single attribute to start requesting\ndata from. Here is an example using the revolvers we created before:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-clojure"}),"(p.eql/process indexes [{[::pi 2.3] [::tau]}])\n; => {[::pi 2.3] {::tau 4.6}}\n")),Object(i.b)("p",null,"In this example, given ",Object(i.b)("inlineCode",{parentName:"p"},"PI")," is ",Object(i.b)("inlineCode",{parentName:"p"},"2.3"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Tau")," becomes ",Object(i.b)("inlineCode",{parentName:"p"},"4.6"),", since it's defined as the\ndouble of PI."),Object(i.b)("h3",{id:"providing-data-with-placeholders"},"Providing data with placeholders"),Object(i.b)("p",null,"You can use placeholders to provide in-query data for Pathom processing. To do this, lets\nget back to our famous full name example, the way to provide data is to send it to\na placeholder key as ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://edn-query-language.org/eql/1.0.0/specification.html#_parameters"}),"EQL parameters"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-clojure"}),'(pco/defresolver full-name [{::keys [first-name last-name]}]\n  {::full-name (str first-name " " last-name)})\n\n(def env (pci/register full-name))\n\n(p.eql/process env\n  [{\'(:>/bret {::first-name "Bret" ::last-name "Victor"})\n    [::full-name]}])\n; => {:>/bret {:com.wsscode.pathom3.docs.placeholder/full-name "Bret Victor"}}\n')),Object(i.b)("p",null,"When moving to a placeholder context, Pathom inherits the same parent data and merges\nthe params data to it, to illustrate let's make a nested example of it:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-clojure"}),'(p.eql/process env\n  [{\'(:>/bret {::first-name "Bret" ::last-name "Victor"})\n    [::full-name\n     {\'(:>/bard {::first-name "Bard"})\n      [::full-name]}]}])\n; {:>/bret\n;   {:com.wsscode.pathom3.docs.placeholder/full-name "Bret Victor",\n;    :>/bard\n;    {:com.wsscode.pathom3.docs.placeholder/full-name "Bard Victor"}}}\n')),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"Placeholders data parameters is a new feature of Pathom 3, not available in Pathom 2."))),Object(i.b)("h3",{id:"union-queries"},"Union queries"),Object(i.b)("p",null,"Union queries provide a way to archive polymorphism in with EQL, for a review on the\nunion syntax refer to the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://edn-query-language.org/eql/1.0.0/specification.html#_unions"}),"EQL Union specification page"),"."),Object(i.b)("p",null,"Consider you want to request information for some user feed. In our feed example, there\nare three types of entries: posts, ads and videos. Each type requires different attributes\nto render. This is how we can write some resolvers to fetch each type:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-clojure"}),'(def union-env\n  (pci/register\n    [(pbir/static-table-resolver `posts :acme.post/id\n       {1 {:acme.post/text "Foo"}})\n     (pbir/static-table-resolver `ads :acme.ad/id\n       {1 {:acme.ad/backlink "http://marketing.is-bad.com"\n           :acme.ad/title    "Promotion thing"}})\n     (pbir/static-table-resolver `videos :acme.video/id\n       {1 {:acme.video/title "Some video"}})\n     (pbir/constantly-resolver :acme/feed\n       [{:acme.post/id 1}\n        {:acme.ad/id 1}\n        {:acme.video/id 1}])]))\n\n(p.eql/process union-env\n  [{:acme/feed\n    {:acme.post/id  [:acme.post/text]\n     :acme.ad/id    [:acme.ad/backlink :acme.ad/title]\n     :acme.video/id [:acme.video/title]}}])\n; => {:acme/feed\n;     [{:acme.post/text "Foo"}\n;      {:acme.ad/backlink "http://marketing.site.com",\n;       :acme.ad/title "Promotion thing"}\n;      {:acme.video/title "Some video"}]}\n')),Object(i.b)("p",null,"To decide which path to take, Pathom looks if the entry data contains the key mentioned\nin the union entry key. When they match Pathom picks that path option."),Object(i.b)("h3",{id:"recursive-queries"},"Recursive queries"),Object(i.b)("p",null,"Some data shapes are trees. For example, if we like to map a file system with Pathom."),Object(i.b)("p",null,"I'll start writing a few resolvers to handle paths and directory navigation:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-clojure"}),"(pco/defresolver file-from-path [{:keys [path]}]\n  {:file (io/file path)})\n\n(pco/defresolver file-name [{:keys [^File file]}]\n  {:file-name (.getName file)})\n\n(pco/defresolver directory? [{:keys [^File file]}]\n  {:directory? (.isDirectory file)})\n\n(pco/defresolver directory-files [{:keys [^File file directory?]}]\n  {:files\n   (if directory?\n     (mapv #(hash-map :file %) (.listFiles file))\n     ::pco/unknown-value)})\n\n(def file-env\n  (pci/register\n    [file-from-path\n     file-name\n     directory?\n     directory-files]))\n")),Object(i.b)("p",null,"To demonstrate the recursive property of it, I'll write the same nested query a few times\nto show it up:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-clojure"}),'(comment\n  (p.eql/process file-env\n    {:path "src"}\n    [:file-name\n     {:files [:file-name\n              {:files [:file-name\n                       {:files []}]}]}]))\n')),Object(i.b)("p",null,"Instead of doing that, we can use ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://edn-query-language.org/eql/1.0.0/specification.html#_recursive_queries"}),"EQL recursive queries"),"\nto handle it:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-clojure"}),'(comment\n  (p.eql/process file-env\n    {:path "src"}\n    [:file-name\n     {:files \'...}]))\n')),Object(i.b)("p",null,"The previous example creates an unbounded recursion. It's going to keep going until\nthere is no more depth to go."),Object(i.b)("p",null,"You can also limit this using bounded recursive queries:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-clojure"}),'(comment\n  (p.eql/process file-env\n    {:path "src"}\n    [:file-name\n     ; max of 2 depths\n     {:files 2}]))\n')),Object(i.b)("h3",{id:"wildcard"},"Wildcard"),Object(i.b)("p",null,"In EQL queries, you can use the special symbol ",Object(i.b)("inlineCode",{parentName:"p"},"*")," to ask Pathom to give all the data\navailable for that entity. In other words, this removes the output filtering at that\nlevel. Here is an example of what it means:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-clojure"}),'; define a resolver that returns multiple things\n(pco/defresolver user-data []\n  {:user/name       "foo"\n   :user/email      "some-user@email.com"\n   :user/birth-year 1988})\n\n; standard query\n(p.eql/process (pci/register user-data)\n    [:user/name])\n; gets the output filtered, only the items in query show up\n=> #:user{:name "foo"}\n\n; making query adding the *\n(p.eql/process (pci/register user-data)\n    [:user/name \'*])\n; now all the data that was loaded in process will show up in the result\n=> #:user{:name "foo", :email "some-user@email.com", :birth-year 1988}\n\n; another example, now we can see the whole deps showing up\n(p.eql/process\n    (pci/register\n      [user-data\n       (pbir/single-attr-resolver :user/name :user/name++ #(str % " - extra things"))])\n    [:user/name++ \'*])\n=>\n#:user{:name++ "foo - extra things",\n       :name "foo",\n       :email "some-user@email.com",\n       :birth-year 1988}\n')),Object(i.b)("div",{className:"admonition admonition-important alert alert--info"},Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"important")),Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"The ",Object(i.b)("inlineCode",{parentName:"p"},"*")," only affects sibling attributes (things at same entity/level), the following\nexample illustrates it:"),Object(i.b)("pre",{parentName:"div"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-clojure"}),'(p.eql/process\n    (pci/register user-data)\n    [{:>/ent1 [:user/name \'*\n               {:>/nested [:user/email]}]}\n     {:>/ent2 [:user/birth-year]}])\n=>\n#:>{:ent1 {:user/name "foo",\n           :>/nested #:user{:email "some-user@email.com"},\n           :user/email "some-user@email.com",\n           :user/birth-year 1988},\n    :ent2 #:user{:birth-year 1988}}\n')))))}p.isMDXComponent=!0},96:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return b}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),p=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=p(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),d=p(n),u=a,b=d["".concat(o,".").concat(u)]||d[u]||m[u]||i;return n?r.a.createElement(b,s(s({ref:t},l),{},{components:n})):r.a.createElement(b,s({ref:t},l))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);