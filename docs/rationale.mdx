---
title: Rationale
---

- Eoliphat chat

5 whys
2nth order impact

Why I'm doing this?
- Processing complex information is hard

- Reference

- find examples online about bad "required"/"optional" cases

;; idea for example: YNAB reconciliation with bank data


The inspiration for Pathom attribute modeling comes from [RDF](https://www.w3.org/RDF/),
[Datomic](https://www.datomic.com/) and [Spec](https://clojure.org/guides/spec).


# Talking with Thome

- bring problems of entity modeling
- entity modeling is not just OOP
  - C structs are entities
  - REST endpoints are mostly entities


Pain points

- Implicit Entity Modeling (Duck Typing)
  - JS
  - Ruby
  - Clojure*
  ...

:track/id
:track/duration

:foreign-track/duration


Track
  - id
  - title
  - duration

integration between companies, integrating the data

ForeignTrack
  - id
  - title
  - duration

DurationItem {
  duration: int;
}

```
fn human-track-duration(track) {
  makeHuman(track.duration)
}

:foreign-track/duration -> :track/duration

fn human-track-duration(:track/duration) {
  makeHuman(track.duration)
}

fn operation(AudioFeaturesInterface) {

}
```

 REQUIRED / OPTIONAL


- Explicit Entity Modeling (more like OOP)
  - Typescript
  - GraphQL
  - Swift
  ...

# Modeling data with attributes

- plan
  - make logic example
  - point associations
  - demo that entity model makes difficult to make this happen
  - pathom to save the day

-- trying to get some example on how we deal with logic property inferences on day to day

Soraya is 29 years old.

The Clojure keywords have a built-in separation of namespace and name, and Pathom leverages
it.

The answer is surprisingly simple: make attribute names bigger!

How big? It needs to big enough to avoid ambiguity.

----

Many ways to identify you:
- Your social security number
- Insurance number
- Email
- Address (if you live by yourself)
-

# Challenges to integrate distributed data

## Entity based modeling dominates the software industry



# Abstract

Pathom is a logical design model implemented in Clojure/script. It is designed to eliminate the
code related to composing functions in the information layer of your program.

## Pervasive Entity modeling

Entity model is a way of thinking about information in terms of entities. We can see
this model in almost every kind of software created today.

:::important
I'll be talking about entity modeling only in the context of information modeling.
:::

I like to bring attention to some challenges that I face when I use this method of
thinking to design information systems.

## Our example, the music stream service

To illustrate the challenges I'll model a generic music stream service:

IMAGE_HERE



;;; because I can compare with Apple Music, or Google Play

### Problem with implicit entities

- you never know if that attribute is really what you expect

```ruby
def full_name(person)
  person.first_name + " " + person.last_name
end
```

```typescript
class Person {
  id: string;
  firstName: string;
  lastName: string;
}

interface Nameable {
  firstName: string;
  lastName: string;
}

function fullName (person: Person): string {
  return person.firstName + " " + person.lastName
}

function fullName (person): string {
  return person.firstName + " " + person.lastName
}
```

### Problem with explicit entities

- refactoring is a pain in the ass

### Expose the issues

- repeated types
  - simplified types
  - required vs optional
  - repetition of attribute definition
-- common pattern, add the `type` attribute
- connecting different entities
- operations are tied by entity
- extracting interfaces is expensive
  - fields with same name, same semantic, different value unit
    - I heard some astronalts had to deal with this
- distinct teams trying to split the same interface
- hard to cross language boundaries

- its pervasive even when types are implicit
  - in JS for example, when a fn requires an id, you assume it its the right kind of id
    because its implicit (sometimes from the fn name, like userById()).

when people are afraid of that, then they turn to TypeScript, with Typescript the type
is explicit, so in this way a compiler can ensure you are consistent with your definitions.

situation where we have to integrate with a remote API

GraphQL brought the same entity modeling to the wire. The good thing is that the model
is now visible.


## Show How Attribute modeling can change it

Demo the initial tables, and convert to properties

- first prefix every property inside the entity with something
- then remove the boxes
- now demonstrate how operations get connected directly to attributes

then we only need to connect the parts that our systems need to care about

trivial to alias attributes

never have to compromise some interface for convenience

render page from song

## inspirations

Datomic
RDF
Spec

## increase visibility of the information flow

## Pathom schema is bottom-up

It is common for systems to first define a schema, and later they implement that schema
in some way. In Pathom, the schema is defined by the resolvers upon registration, it
is more like something that gets add, instead of planned ahead.

## Pathom design is about the relationship between attributes.

In Pathom, the resolvers are responsible for defining the attribute connections.



Instead of doing schema first, and then implementation, in Pathom, resolvers
define the schema upon registration.

# The problem through example

To understand the reasoning around Pathom, let's split our definition of code in two types: Implementors and Composers.

## Schema

## Accessors

## Implementors

Those are functions that do actual work, like:

- Reading data from a database
- Transforming data
- Running calculations

This is to me where most of the fun in coding is, the real specific logic about your
application.

## Why Pathom?

I did

### Automated Controllers

* A lot of errors in software come from small mistakes when connecting functions in controllers

### Clojure/script solution

* With support
