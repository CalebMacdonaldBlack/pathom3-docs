---
title: Resolvers
---

Resolvers are the primary building blocks in Pathom. They are the constructs to express
relationships between attributes.

In this page you will learn how to create resolvers and use then. After that you
will learn about the built-in resolvers that come with Pathom.

## What is a resolver in Pathom?

The Pathom engine gather its resolution features from the relationship between attributes.
Resolvers are the piece that express those relationships.

To put in more concrete terms, imagine that you have some user id, and you want to know
what is the birth year of the user. In Pathom we express this relationship using the attributes
`:acme.user/id` and `:acme.user/birth-year` for example.

Now we need to implement how to fetch the name from the id, this can be a lookup in a
database, or in a map, or any way, doesn't matter. What matters is that you express
this connection, and provide code that makes it happen.

Here I'll illustrate this using a map lookup:

```clojure
(def user-birthdays
  {1 1969
   2 1954
   3 1986})

; defresolver is the main option to create new resolvers
(pco/defresolver user-birthday [{:keys [acme.user/id]}]
  {:acme.user/birth-year (get user-birthdays id)})
```

In Pathom, resolvers represent edges in a graph. As illustrated in the following figure:

:::note
I'll short then names on the diagrams for space, but keep your domain qualifiers long!
:::

<div className="pathom-diagram">

  ![](./assets/diagrams/resolver.svg)

</div>

This example was a simplification, most systems will store the full birth date instead,
and then extract the year from this date.

We can simulate such case using the following setup:

```clojure
; define a map for indexed access to user data
(def users-db
  {1 #:acme.user{:name     "Usuario 1"
                 :email    "user@provider.com"
                 :birthday "1989-10-25"}
   2 #:acme.user{:name     "Usuario 2"
                 :email    "anuser@provider.com"
                 :birthday "1975-09-11"}})

; pull stored user info from id
(pco/defresolver user-by-id [{:keys [acme.user/id]}]
  {::pco/output
   [:acme.user/name
    :acme.user/email
    :acme.user/birthday]}
  (get users-db id))

; extract birth year from birthday
(pco/defresolver birth-year [{:keys [acme.user/birthday]}]
  {:acme.user/birth-year (first (str/split birthday #"-"))})
```

Here is a diagram from the previous setup:

<div className="pathom-diagram">

  ![](./assets/diagrams/resolver-birthday-extended.svg)

</div>


## Using `defresolver`

The macro `defresolver` is the primary way to create new resolvers. It has some sugars
to reduce the boilerplate code related to define a new resolver.

The main pieces of a resolver are:

- `::pco/op-name` - a symbol that identify the resolver, like a function name.
- `::pco/output` - a EQL expression that informs the attributes **provided** by this resolver.
- `::pco/input` - a EQL expression that informs the attributes **required** by this resolver.

Let's start with a verbose usage of `defresolver` to go over these main pieces:

```clojure
; this resolver computes a slug to use on URL from some article title
(pco/defresolver article-slug [env {:acme.article/keys [title]}]
  {::pco/op-name `article-slug
   ::pco/input   [:acme.article/title]
   ::pco/output  [:acme.article/slug]}
  {:acme.article/slug (str/replace title #"[^a-z0-9A-Z]" "-")})
```

:::note Design observation
This resolver expresses an edge in Pathom attribute world, it says the attribute `:acme.article/slug`
is reachable, given that a `:acme.article/title` is available.
:::

If you look close you can find a fair amount of repetition in this expression:
- The `op-name` is repeated at the start to define the `var` name.
- The `input` is repeated in the destructuring expression.
- The `output` is visible in the output expression.

Experience with Pathom 2 demonstrated these repetitions occur frequently in most Pathom
code bases. So Pathom 3 adds some extra sugar tricks to avoid the repetition:

1. We can remove the `::pco/op-name` and let `defresolver` use the same symbol as the `var`:

```clojure
(pco/defresolver article-slug [env {:acme.article/keys [title]}]
  {::pco/input  [:acme.article/title]
   ::pco/output [:acme.article/slug]}
  {:acme.article/slug (str/replace title #"[^a-z0-9A-Z]" "-")})
```

:::tip
If you use [Cursive](https://cursive-ide.com/), you can ask it to resolve the
`pc/defresolver` as a `defn`, and you will get proper symbol resolution
:::

2. Now, given the `input` is the same as destructuring, we can let `defresolver` infer the input from it:

```clojure
(pco/defresolver article-slug [env {:acme.article/keys [title]}]
  {::pco/output [:acme.article/slug]}
  {:acme.article/slug (str/replace title #"[^a-z0-9A-Z]" "-")})
```

3. Since the last element of our expression is a map, `defresolver` can infer the `output` from it:

```clojure
; given the map would be empty now, we can remove it completely
(pco/defresolver article-slug [env {:acme.article/keys [title]}]
  {:acme.article/slug (str/replace title #"[^a-z0-9A-Z]" "-")})
```

:::important
Pathom only looks at the last item of the body for implicit outputs, this means that
if you wrap the map with something like a `let` statement, Pathom will not be able
to figure it out. Instead, you can move the `let` down on the attribute level:

```clojure
(pco/defresolver foo []
  ; infer won't work, the last statement is a let
  (let [x 10]
    {:foo x}))

(pco/defresolver foo []
  ; works
  {:foo (let [x 10] x)})
```

In the future Pathom may get smarter around this, but this is a long rabbit role when
I consider that the last user statement may be an `if`, `cond`, etc...
:::

:::note
Although Pathom can infer the configuration, you can always override it using the
options map.
:::

4. Given we are not using `env`, we can also take it out, taking us to the final version:

```clojure
(pco/defresolver article-slug [{:acme.article/keys [title]}]
  {:acme.article/slug (str/replace title #"[^a-z0-9A-Z]" "-")})
```

:::tip
In case you have a resolver that don't use an input, you can omit the first argument
as well, for example:

```clojure
(pco/defresolver constant-pi []
  {:acme.math/pi 3.1415})
```
:::

## Invoking resolvers

Like functions, you can call the resolvers directly. The arity to call resolver is similar
to how to define resolvers:

```clojure
(pco/defresolver extension [{::keys [path]}]
  {::path-ext (last (str/split path #"\."))})

(extension {::path "foo.txt"})
; => {::path-ext "txt"}
```

This makes easier to test resolvers in unit tests.

Outside of test context, you should have little reason to invoke a resolver directly. What
sets resolvers apart from regular functions is that it contains data about its requirements
and what it provides.

This allows you to abstract away the operation names, and focus only on the attributes.

To illustrate the difference, let's compare the two approaches, first let's define the resolvers:

```clojure
(ns com.wsscode.pathom.docs.resolvers-demos
  (:require [clojure.string :as str]
            [com.wsscode.pathom3.connect.built-in.resolvers :as pbir]
            [com.wsscode.pathom3.connect.indexes :as pci]
            [com.wsscode.pathom3.connect.operation :as pco]
            [com.wsscode.pathom3.interface.smart-map :as psm]))

(def user-from-id
  (pbir/static-table-resolver `user-db :acme.user/id
    {1 #:acme.user{:name  "Trey Parker"
                   :email "trey@provider.com"}
     2 #:acme.user{:name  "Matt Stone"
                   :email "matt@provider.com"}}))

; avatar slug is a version of email, converting every non letter character into dashes
(pco/defresolver user-avatar-slug [{:acme.user/keys [email]}]
  {:acme.user/avatar-slug (str/replace email #"[^a-z0-9A-Z]" "-")})

(pco/defresolver user-avatar-url [{:acme.user/keys [avatar-slug]}]
  {:acme.user/avatar-url (str "http://avatar-images-host/for-id/" avatar-slug)})
```

Now, consider the question: Given I want to know the `avatar url` of the user with id `1`.

The traditional way to get there using our resolvers as functions goes as:

```clojure
(-> {:acme.user/id 1}
    (user-from-id)
    (user-avatar-slug)
    (user-avatar-url)
    :acme.user/avatar-url)
; => "http://avatar-images-host/for-id/trey-provider-com"
```

Now check a few examples of how we can accomplish the same using the a [smart map](smart-maps.mdx)
leveraged by the resolvers meta-data:

```clojure
; first we build a index for the relations expressed by the resolvers
(def indexes
  (pci/register [user-from-id
                 user-avatar-slug
                 user-avatar-url]))

; now instead of reference the functions, we let Pathom figure them out using the indexes
(->> {:acme.user/id 2}
     (psm/smart-map indexes)
     :acme.user/avatar-url)
; => "http://avatar-images-host/for-id/matt-provider-com"

; to highlight the fact that we disregard the function, other ways where we can change
; the initial data and reach the same result:
(->> {:acme.user/email "other@provider.com"}
     (psm/smart-map indexes)
     :acme.user/avatar-url)
; => "http://avatar-images-host/for-id/other-provider-com"

(->> {:acme.user/avatar-slug "some-slogan"}
     (psm/smart-map indexes)
     :acme.user/avatar-url)
; => "http://avatar-images-host/for-id/some-slogan"
```

Note how as we change the input, Pathom adjusts the resolvers required to call, this
is the main thing that Pathom brings to you, <mark>it removes the chore of knowing the
function names</mark>, so you can focus on the data you have/need and not how to get it.

## Generate the indexes

Here we will cover in more details the process to generate the indexes from resolvers.

Think of resolvers as the **atomic blocks of Pathom**, which are annotated functions. If Pathom had to scan
every resolver to figure a path it would be slow. So instead Pathom works on indexes
generated from a set of resolvers.

To generate the indexes we use the function `(pci/register ...)`. The values allowed
on register are:

- resolvers
- mutations
- indexes
- sequence of previous items (recursively)

Here are a couple of examples to illustrate:

```clojure
; create indexes for a single resolver
(def single-registry (pci/register some-resolver))

; creating indexes with a few resolvers
(def many-registry (pci/register [resolver-a resolver-b]))

; define a group of resolvers in a variable
(def some-resolvers [res-a res-b])

; now use in combination with other mixes:
(def more-registry
  (pci/register [some-resolvers
                 [other-group with-more
                  [deep-nested resolvers]]
                 and-more]))

; now using indexes as part of registry
(def with-indexes (pci/register [some-resolvers many-registry]))

; all together now
(def all-together
  (pci/register [[resolver-a resolver-b]
                 some-resolvers
                 many-registry]))
```

To learn more details about the indexes, check the [indexes page](indexes.mdx).

## Using `resolver`

You can also create a resolver using the `resolver` helper, this is more useful when
you are making some helper function to generate a resolver.

To create a resolver using `pco/resolver` you have the following options:

```clojure
; using helper syntax
(pco/resolver `op-name
  {::pco/output [::foo]}
  (fn [env input] {::foo "bar"}))

; using config map
(pco/resolver
  {::pco/op-name `op-name
   ::pco/output  [::foo]
   ::pco/resolve (fn [env input] {::foo "bar"})})
```

As an example, here are how to generate resolvers to create unit conversion between
meters and feet:

```clojure
(defn alias-resolver
  "Create a resolver that will convert attribute `from` to a attribute `to` with
  the same value. This only creates the alias in one direction."
  [from to]
  (let [resolver-name (symbol (str (attr-alias-resolver-name from to) "-alias"))]
    (pco/resolver resolver-name
      {::pco/input  [from]
       ::pco/output [to]}
      (fn [_ input] {to (get input from)}))))
```

## Built-in Resolvers

Pathom comes with built-in resolvers to handle common situations. You will find these
resolver generators at:

```clojure
[com.wsscode.pathom3.connect.built-in.resolvers :as pbir]
```

### Constants

This is a simple way to express a constant value for a given attribute.

```clojure
(pbir/constantly-resolver :math/PI 3.1415)
```

### Aliasing

You can use alias to create a resolver that provides one attribute based on the same
value of another:

```clojure
(pbir/alias-resolver :specific.impl.product/id :generic.ui.product/id)

; is equivalent to:

(pco/defresolver spec->generic-prod-id [{:specific.impl.product/keys [id]}]
  {:generic.ui.product/id id})
```

Like the example suggests, you can use alias to make some specific name and make it align
generically with some other domain name.

Note that this only goes in one direction, to illustrate this, consider the extended
example here:

```clojure
(def indexes
  (pci/register
    [specific-impl-registry
     another-impl-option
     (pbir/alias-resolver :specific.impl.product/id :generic.ui.product/id)
     (pbir/alias-resolver :another.impl.product/id :generic.ui.product/id)]))
```

:::note
A practical side of using this helper is that the helper will generate a name for the
resolver for you, this alleviates the chore of repetitive writing, and makes the alias
names look like each other. Try checking the resolver name for the alias resolvers
from the previous example.
:::

In this case, both `:specific.impl.product/id` and `:another.impl.product/id` are valid
value to show for `:generic.ui.product/id`; but if you have only the `:generic.ui.product/id`,
you can't know if its from `specific` or `another` impl.

### Equivalence

Use this to express that two attributes are equivalent, that they share the same semantics.
For example:

```clojure
(pbir/equivalence-resolver :acme.product/upc :affiliate.product/upc)
```

This is a common tool to integrate attributes from different domains.

In practice, it creates one alias resolver for each direction, any resolver that uses
the first will also work with the second, and vice versa.

### Simple one-to-one transformation

This helper gives an easy way to convert one attribute into another, modified by a
function. A common use case is to convert some attribute from one unit to another unit
under a different name. For example:

```clojure
; in this example we create one different transformation for each direction
(def registry
  [(pbir/single-attr-resolver :acme.track/duration-ms :affiliate.track/duration-seconds #(/ % 1000))
   (pbir/single-attr-resolver :affiliate.track/duration-seconds :acme.track/duration-ms #(* % 1000))])

(def indexes (pci/register registry))

(-> (psm/smart-map indexes {:acme.track/duration-ms 324000})
    :affiliate.track/duration-seconds)
; => 324

(-> (psm/smart-map indexes {:affiliate.track/duration-seconds 324})
    :acme.track/duration-ms)
; => 324000
```

The function receives a single argument, which is the value of the `source` attribute;
and returns the value for `target` attribute.

If your transformation also requires access to `env`, use `single-attr-with-env-resolver`
instead, then the arglist of `f` is `[env input-attribute-value]`.

### Static Tables

You can use static tables to provide extra data for some entities, given some identifier.

```clojure
(def registry
  [(pbir/static-table-resolver `song-names :song/id
     {1 {:song/name "Marchinha Psicotica de Dr. Soup"}
      2 {:song/name "There's Enough"}})

   ; note you need to provide the name for the resolver, prefer fully qualified symbols
   (pbir/static-table-resolver `song-analysis :song/id
     {1 {:song/duration 280 :song/tempo 98}
      2 {:song/duration 150 :song/tempo 130}})])

(let [sm (psm/smart-map (pci/register registry)
           {:song/id 1})]
  (select-keys sm [:song/id :song/name :song/duration]))
; => #:song{:id 1, :name "Marchinha Psicotica de Dr. Soup", :duration 280}
```

This helper infers the output from the table data.

### Attribute Map

This one is similar to static tables, but to provide a single attribute for each entity
instead of many:

```clojure
(def registry
  [(pbir/attribute-map :song/id :song/name
     {1 "Marchinha Psicotica de Dr. Soup"
      2 "There's Enough"})

   ; note you need to provide the name for the resolver, prefer fully qualified symbols
   (pbir/static-table-resolver `song-analysis :song/id
     {1 {:song/duration 280 :song/tempo 98}
      2 {:song/duration 150 :song/tempo 130}})])

(let [sm (psm/smart-map (pci/register registry)
           {:song/id 1})]
  (select-keys sm [:song/id :song/name :song/duration]))
; => #:song{:id 1, :name "Marchinha Psicotica de Dr. Soup", :duration 280}
```

### Attribute Tables

This is also similar to static tables, but the table data comes from another attribute instead
of static data.

Because in this case the data is opaque, you need to express which keys will trigger
this table attribute lookup. This example is similar to the one from static tables, but
this time we will mix one static table with one attribute table.

```clojure
(def registry
  [(pbir/static-table-resolver `song-names :song/id
     {1 {:song/name "Marchinha Psicotica de Dr. Soup"}
      2 {:song/name "There's Enough"}})

   ; provide table in the attribute ::song-analysis
   (pbir/constantly-resolver ::song-analysis
     {1 {:song/duration 280 :song/tempo 98}
      2 {:song/duration 150 :song/tempo 130}})

   ; ref the attribute, the index attribute and the output that triggers this resolver
   (pbir/attribute-table-resolver ::song-analysis :song/id
     [:song/duration :song/tempo])])

(let [sm (psm/smart-map (pci/register registry)
           {:song/id 2})]
  (select-keys sm [:song/id :song/name :song/duration]))
; => #:song{:id 2, :name "There's Enough", :duration 150}
```

### EDN Files

Load attributes from a EDN file.

This is macro made to load some configuration from EDN at compilation time. It's an
easy way to source some data from a file.

Basic example, given this configuration file:

```clojure title="my-config.edn"
{:my.system.server/port
 1234

 :my.system.resources/path
 "resources/public"}
```

Loading with `edn-file-resolver`:

```clojure
; app
(pco/defresolver full-url [{:keys [my.system.server/port my.system.resource/path]}]
  {::server-url (str "http://localhost:" port "/" path)})

(def registry
  [(edn-file-resolver "my-config.edn")
   full-url])

(-> (psm/smart-map (pci/register registry))
    ::server-url)
; => "http://localhost:1234/resources/public
```

#### Attribute tables on EDN Files

You can also provide attribute tables as part of the EDN configuration. To do so, you
add the `:com.wsscode.pathom3/entity-table` key to the map meta, the value here defines
which is the key to index the table data.

```clojure title="my-config-with-table.edn"
{:my.system.server/port
 1234

 :my.system.resources/path
 "resources/public"

 :my.system/generic-db
 ^{:com.wsscode.pathom3/entity-table :my.system/user-id}
 {4 {:my.system.user/name "Anne"}
  2 {:my.system.user/name "Fred"}}}
```

```clojure
; app
(def registry (edn-file-resolver "my-config.edn"))

(let [sm (psm/smart-map (pci/register registry) {:my.system/user-id 4})]
  (select-keys sm [:my.system/port :my.system.user/name]))
; => {:my.system/port 1234, :my.system.user/name "Anne"}
```

:::important
Because this helper is a macro, it works on Clojurescript as well, but remember that
it will pull the data from the EDN file at compilation time, not at runtime.
:::
