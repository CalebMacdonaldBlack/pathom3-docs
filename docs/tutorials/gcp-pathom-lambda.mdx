---
title: GCP Pathom Lambda
---

In this tutorial we are going to implement a Pathom server and deploy it
as a lambda on [Google Cloud Platform](https://cloud.google.com/).

We will start with the code created at the [Pathom Tutorial](../tutorial.mdx), and make
it available as a service.

## Project Setup

To make the GPC integration I'll use the library [google-cloud-function-ring-adapter](https://github.com/pepijn/google-cloud-function-ring-adapter).

Example setup for `deps.edn`:

```clojure
{:paths
 ["src/main" "src/java"]

 :deps
 {com.wsscode/pathom3                        {:git/url "https://github.com/wilkerlucio/pathom3" :sha "3441c195a76cbea80a0c5e56cfcfa38b0b4cc579"}
  metosin/muuntaja                           {:mvn/version "0.6.8"}
  nl.epij/google-cloud-function-ring-adapter {:mvn/version "0.1.0-SNAPSHOT"}
  org.clojure/clojure                        {:mvn/version "1.10.3"}
  org.clojure/core.async                     {:mvn/version "1.3.618"}
  ring-cors/ring-cors                        {:mvn/version "0.1.13"}}

 :aliases
 {:assemble
  {:extra-deps {nl.epij.gcf/deploy {:git/url   "https://github.com/pepijn/google-cloud-function-ring-adapter"
                                    :sha       "ede2ccee2fec5a526350622f32a39fac95bb0273"
                                    :deps/root "deploy"}}
   :exec-fn    nl.epij.gcf.deploy/assemble-jar!
   :exec-args  {:nl.epij.gcf/entrypoint   PathomServer
                :nl.epij.gcf/java-paths   ["src/java"]
                :nl.epij.gcf/compile-path "target/classes"
                :nl.epij.gcf/jar-path     "target/artifacts/application.jar"}}
  :run
  {:extra-deps {nl.epij.gcf/deploy {:git/url   "https://github.com/pepijn/google-cloud-function-ring-adapter"
                                    :sha       "ede2ccee2fec5a526350622f32a39fac95bb0273"
                                    :deps/root "deploy"}}
   :exec-fn    nl.epij.gcf.deploy/run-server!
   :exec-args  {:nl.epij.gcf/entrypoint   PathomServer
                :nl.epij.gcf/java-paths   ["src/java"]
                :nl.epij.gcf/compile-path "target/classes"
                :nl.epij.gcf/jar-path     "target/artifacts/application.jar"}}}}
```

## Ring handler setup

Now let's setup a [Ring](https://github.com/ring-clojure/ring) handler. The two main things
for this:

1. Setup content negotiation to decode/encode data, I'll use [muuntaja](https://github.com/metosin/muuntaja).
2. Handle the request using the [Pathom Boundary Interface](../eql.mdx#boundary-interface).

```clojure
(ns com.wsscode.pathom-server
  (:require
    ; to include the env setup from the Tutorial demo
    [com.wsscode.pathom3.demos.ip-weather :refer [env]]

    [com.wsscode.pathom3.connect.operation.transit :as pcot]
    [com.wsscode.pathom3.interface.eql :as p.eql]
    [muuntaja.core :as muuntaja]
    [muuntaja.middleware :as middleware]))

; create a boundary interface
(def interface (p.eql/boundary-interface env))

(defn handler [{:keys [body-params]}]
  {:status 200
   :body   (interface body-params)})

(def muuntaja-options
  (update-in
    muuntaja/default-options
    [:formats "application/transit+json"]
    ; in this part we setup the read and write handlers for Pathom resolvers and mutations
    merge {:decoder-opts {:handlers pcot/read-handlers}
           :encoder-opts {:handlers pcot/write-handlers}}))

(def app
  (-> handler
      (middleware/wrap-format muuntaja-options)))
```

:::tip
This same handler setup works with any other ring server, like [Pedestal](http://pedestal.io/),
[http-kit](https://http-kit.github.io/), [Compojure](https://github.com/weavejester/compojure),
etc...
:::

The boundary interface isn't required, but it gives extra capabilities to the clients
like allow the user to provide root data.

Now to hook that we need to create a Java file in our sources, that will link our handler:

```java
import nl.epij.gcp.gcf.RingHttpFunction;

public class PathomServer extends RingHttpFunction {
    public String getHandler() {
        return "com.wsscode.pathom-server/app";
    }
}
```

After this part we can test our server locally:

```
PORT=13337 clojure -X:run
```

Once it runs, we can test it sending a request:

```
curl --location --request POST 'http://localhost:13337' \
--header 'Content-Type: application/edn' \
--header 'Accept: application/edn' \
--data-raw '{:pathom/tx [:temperature], :pathom/entity {:ip "198.29.213.3"}}'
```

## GCP Setup

For the next steps you need to have [GCP Account](https://accounts.google.com/signin/v2/identifier?service=cloudconsole&passive=1209600&osid=1&continue=https%3A%2F%2Fconsole.cloud.google.com%2Ffreetrial%2Fsignup%2Ftos%3Fref%3Dhttps%3A%2F%2Fwww.google.com%2F&followup=https%3A%2F%2Fconsole.cloud.google.com%2Ffreetrial%2Fsignup%2Ftos%3Fref%3Dhttps%3A%2F%2Fwww.google.com%2F&flowName=GlifWebSignIn&flowEntry=ServiceLogin)
and install the [Google Cloud SDK](https://cloud.google.com/sdk/docs/install).

:::tip
On Mac you can install GCP with `brew install google-cloud-sdk`
:::

To deploy the handler as lambda, first we assemble the jar:

```
clojure -X:assemble
```

Deploy to GCP:

```
gcloud functions deploy --runtime java11 --source target/artifacts/ --max-instances 1 development-pathom-server-demo --trigger-http --allow-unauthenticated --entry-point PathomServer --memory 2GB --timeout 270
```

If you go through with no errors the lambda should be online!

You can find out the URL to try it at the Google Console: https://console.cloud.google.com/functions/list?project=YOUR_PROJECT

There, find the lambda and navigate to the `Trigger` tab.
